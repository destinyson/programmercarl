# 二叉树理论基础

## 二叉树存储、遍历与定义方式

- 二叉树存储：
  - 二叉树可以链式存储（用指针），也可以顺序存储（用数组）
    - 链式存储方式就用指针， 顺序存储的方式就是用数组
    - 链式存储，即将树视为二叉链表，通过指针把分布在散落在各个地址的节点串联一起
    - 顺序存储，即将树视为静态链表，如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2
- 二叉树遍历：二叉树主要有两种遍历方式
  - 深度优先遍历：先往深走，遇到叶子节点再往回走。进一步拓展，有如下遍历方式：
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
  - 广度优先遍历：一层一层的去遍历
    - 层次遍历（迭代法）
- 二叉树定义方式：通常用链式存储的方式
```
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 递归相关

- 返回值：通常来说
  - 如果需要遍历整棵树，递归函数就不能有返回值
  - 如果需要遍历某一条固定路线，递归函数就一定要有返回值

## 经典题目与技巧

- 二叉树是笔试面试的常客。例题中，绝大部分都提供了递归与迭代两种思路，其中迭代利用栈和队列这两种数据结构实现

### 二叉树遍历
- 二叉树遍历的递归法比较好理解，主要观察迭代法
  - 深度优先遍历的迭代法，通常利用栈实现；而广度优先遍历的迭代法，通常利用队列实现
  - 对于深度优先遍历的迭代法，有两种写法，可以根据需求选择更好的写法：
    - 利用统一模板便于代码改写，也更容易理解，但需要额外的空间存储nullptr的栈元素，用于标记遍历过的节点
    - 利用非统一模板需要搞清其中逻辑，但会节省空间
- 后面的其他类型问题也会或多或少有遍历的影子，关于遍历顺序的判别：
  - 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点
  - 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算
  - 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性
- 对应问题：
  - 深度优先遍历
    - [144-二叉树的前序遍历](例题/144-二叉树的前序遍历.md)
    - [145-二叉树的后序遍历](例题/145-二叉树的后序遍历.md)
    - [94-二叉树的中序遍历](例题/94-二叉树的中序遍历.md)
    - [589-N叉树的前序遍历](例题/589-N叉树的前序遍历.md)
    - [590-N叉树的后序遍历](例题/590-N叉树的后序遍历.md)
  - 广度优先遍历
    - [102-二叉树的层序遍历](例题/102-二叉树的层序遍历.md)
    - [107-二叉树的层序遍历II](例题/107-二叉树的层序遍历II.md)
    - [199-二叉树的右视图](例题/199-二叉树的右视图.md)
    - [637-二叉树的层平均值](例题/637-二叉树的层平均值.md)
    - [429-N叉树的层序遍历](例题/429-N叉树的层序遍历.md)
    - [515-在每个树行中找最大值](例题/515-在每个树行中找最大值.md)
    - [116-填充每个节点的下一个右侧节点指针](例题/116-填充每个节点的下一个右侧节点指针.md)
    - [117-填充每个节点的下一个右侧节点指针II](例题/117-填充每个节点的下一个右侧节点指针II.md)

### 深度优先遍历相关问题
- 通常利用栈进行迭代。遇到这类问题时，首先要确认需要采用何种遍历方式，然后套用对应遍历方式的模板即可
- 同时，注意递归与迭代时参与递归的变量变化
- 对应问题：
  - [226-翻转二叉树](例题/226-翻转二叉树.md)
  - [101-对称二叉树](例题/101-对称二叉树.md)
  - [100-相同的树](例题/100-相同的树.md)
  - [572-另一棵树的子树](例题/572-另一棵树的子树.md)
  - [110-平衡二叉树](例题/110-平衡二叉树.md)
  - [404-左叶子之和](例题/404-左叶子之和.md)
  - [617-合并二叉树](例题/617-合并二叉树.md)

### 广度优先遍历相关问题
- 通常利用队列进行迭代
- 对应问题：
  - [104-二叉树的最大深度](例题/104-二叉树的最大深度.md)
  - [559-N叉树的最大深度](例题/559-N叉树的最大深度.md)
  - [111-二叉树的最小深度](例题/111-二叉树的最小深度.md)
  - [222-完全二叉树的节点个数](例题/222-完全二叉树的节点个数.md)
  - [513-找树左下角的值](例题/513-找树左下角的值.md)

### 回溯相关问题
- 回溯的本质就是深度优先遍历，通常用递归实现，正所谓回溯与递归是一一对应的
- 当然，理论上所有递归的程序都可以通过栈或队列用迭代实现，但涉及回溯的程序用迭代实现并不友好，而且容易出现逻辑错误，建议用递归实现
- 对应问题：
  - [257-二叉树的所有路径](例题/257-二叉树的所有路径.md)
  - [112-路径总和](例题/112-路径总和.md)
  - [113-路径总和II](例题/113-路径总和II.md)
  - [236-二叉树的最近公共祖先](例题/236-二叉树的最近公共祖先.md)

### 二叉树构造
- 二叉树的构造，通常涉及向量分割。建议最初构建新向量进行递归，这样更利于理解，熟练后再改成下标传参，向量传引用，这样可以节省空间，只是此时下标需要仔细计算
- 对应问题：
  - [106-从中序与后序遍历序列构造二叉树](例题/106-从中序与后序遍历序列构造二叉树.md)
  - [105-从前序与中序遍历序列构造二叉树](例题/105-从前序与中序遍历序列构造二叉树.md)
  - [654-最大二叉树](例题/654-最大二叉树.md)
  - [108-将有序数组转换为二叉搜索树](例题/108-将有序数组转换为二叉搜索树.md)

### 二叉搜索树操作
- 二叉搜索树的定义与特点：
  - 二叉搜索树是一个有序树：
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉搜索树
- 容易得到，二叉搜索树的中序遍历序列就是一个递增序列
- 由于二叉搜索树的特殊性质，查找节点时不再需要回溯，而是可以固定路径
- 二搜索叉树的增删操作：
  - 二叉搜索树的增加节点：很简单，直接根据二叉搜索树的特点搜索应当插入的位置即可
  - 二叉搜索树删除节点：有以下五种情况
    - 第一种情况：没找到删除的节点，遍历到空节点直接返回了
    - 找到删除的节点
      - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
      - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
      - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
      - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点
- 对应问题：
  - [700-二叉搜索树中的搜索](例题/700-二叉搜索树中的搜索.md)
  - [98-验证二叉搜索树](例题/98-验证二叉搜索树.md)
  - [530-二叉搜索树的最小绝对差](例题/530-二叉搜索树的最小绝对差.md)
  - [501-二叉搜索树中的众数](例题/501-二叉搜索树中的众数.md)
  - [235-二叉搜索树的最近公共祖先](例题/235-二叉搜索树的最近公共祖先.md)
  - [701-二叉搜索树中的插入操作](例题/701-二叉搜索树中的插入操作.md)
  - [450-删除二叉搜索树中的节点](例题/450-删除二叉搜索树中的节点.md)
  - [669-修剪二叉搜索树](例题/669-修剪二叉搜索树.md)
  - [538-把二叉搜索树转换为累加树](例题/538-把二叉搜索树转换为累加树.md)