# 动态规划理论基础

## 动态规划的概念

- 动态规划，英文：Dynamic Programming，简称DP
- 动态规划往往用于有很多重叠子问题的问题，因为重复计算会浪费大量的时间
- 动态规划中每一个状态一定是由上一个状态推导出来的

## 动态规划的解题步骤
- 对于动态规划问题，可以拆解为如下五步：
  - 确定dp数组（dp table）以及下标的含义
  - 确定递推公式
  - dp数组如何初始化
  - 确定遍历顺序
  - 举例推导dp数组
- 由于部分情况下，递推公式决定了dp数组的初始化方式，所以要先确定递推公式，然后再考虑初始化
- 最后一步往往用于debug
  - 做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果
  - 然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样
  - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了
  - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题

## 经典题目与技巧

- 动态规划的核心是状态转移，这也是动态规划和贪心的根本区别：贪心的核心是局部最优策略的选取，而局部最优策略的选取与状态是无关的
- 前面提到了，动态规划的解题步骤。其中，最重要的一步是：dp数组与下标的含义。可以看出，递推公式、dp数组的初始化方式与遍历顺序，都能通过含义得到

### 基础问题
- 对应问题：
  - [509-斐波那契数](例题/509-斐波那契数.md)
  - [70-爬楼梯](例题/70-爬楼梯.md)
  - [746-使用最小花费爬楼梯](例题/746-使用最小花费爬楼梯.md)
  - [62-不同路径](例题/62-不同路径.md)
  - [63-不同路径II](例题/63-不同路径II.md)
  - [343-整数拆分](例题/343-整数拆分.md)
  - [96-不同的二叉搜索树](例题/96-不同的二叉搜索树.md)

### 背包问题
- 背包问题有很多种。对于面试来说，通常会考察两种：0-1背包和完全背包
  - 0-1背包：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。根据之前提出的五步，开始分析：
    - 确定dp数组以及下标的含义：对于背包问题，有一种写法，是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少
    - 确定递推公式：由于dp数组与下标的意义，可以有两个方向推出来dp[i][j]
      - 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同)
      - 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值
      - 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
    - dp数组如何初始化：初始化一定要和dp数组的定义吻合。从dp[i][j]的定义出发：
      - 如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0
      - 对于dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值
        - 那么很明显当 j < weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小
        - 当j >= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品
    - 确定遍历顺序：可以看出，有两个遍历的维度：物品与背包重量。通常来说，二者遍历先后其实并没有区别，但是先遍历物品更好理解
    - 举例推导dp数组：可以自行距离推导，但注意，时刻要遵循dp数组与下标的意义
  - 滚动数组：二维dp数组的状态压缩产物
    - 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
    - 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])
    - 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）
  - 对于滚动数组的步骤分析：
    - 确定dp数组的定义：在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]
    - 一维dp数组的递推公式：dp[j]可以通过dp[j - weight[i]]推导出来
      - 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i
      - 所以递归公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
    - 一维dp数组如何初始化：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]
      - 那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0
      - dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数，那么非0下标都初始化为0就可以了
    - 一维dp数组遍历顺序：和二维dp的写法相比，遍历背包的顺序是不一样的：二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小
      - 倒序遍历是为了保证物品i只被放入一次；但如果一旦正序遍历了，那么物品0就会被重复加入多次
      - 而对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖
      - 对于两个嵌套for循环的顺序：要先遍历物品，嵌套遍历背包容量。因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品
      - 注意：一维dp数组的背包在遍历顺序上和二维其实是有很大差异的
    - 举例推导dp数组：可以自行距离推导，但注意，时刻要遵循dp数组与下标的意义
  - 完全背包：完全背包是0-1背包稍作变化而来的，即：完全背包的物品数量是无限的
    - 0-1背包和完全背包唯一不同就是体现在遍历顺序上，所以直接针对遍历顺序进行分析：
    - 根据前文，0-1背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次
    - 而完全背包的物品是可以添加多次的，所以要从小到大去遍历
    - 关于两层for循环的内外顺序：
      - 纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，所以两层循环的内外顺序对结果并无影响
      - 但若题目求的是凑成总和的组合数，元素之间要求没有顺序，那么就要外层for循环遍历物品，内层for遍历背包
      - 相反，若题目求的是凑成总和的排列数，元素之间要求有顺序，那么就要外层for循环遍历背包，内层for遍历物品
      - 若不是很理解，建议动手把这两种方案的dp数组数值变化打印出来，观察dp数组的变化过程
- 对应问题：
  - 0-1背包：
    - [416-分割等和子集](例题/416-分割等和子集.md)
    - [1049-最后一块石头的重量II](例题/1049-最后一块石头的重量II.md)
    - [494-目标和](例题/494-目标和.md)
    - [474-一和零](例题/474-一和零.md)
  - 完全背包：
    - [518-零钱兑换II](例题/518-零钱兑换II.md)
    - [377-组合总和IV](例题/377-组合总和IV.md)
    - [322-零钱兑换](例题/322-零钱兑换.md)
    - [279-完全平方数](例题/279-完全平方数.md)
    - [139-单词拆分](例题/139-单词拆分.md)

### 打家劫舍问题
- 这一类问题只要搞清dp数组与下标的定义，以及状态转移方程，难度并不高
- 对应问题：
  - [198-打家劫舍](例题/198-打家劫舍.md)
  - [213-打家劫舍II](例题/213-打家劫舍II.md)
  - [337-打家劫舍III](例题/337-打家劫舍III.md)

### 股票问题
- 股票问题其实就是完全背包的变种，要注意状态转移，通过状态转移的定义确定dp数组与下标的定义
- 对应问题：
  - [121-买卖股票的最佳时机](例题/121-买卖股票的最佳时机.md)
  - [122-买卖股票的最佳时机II](../9-贪心/例题/122-买卖股票的最佳时机II.md)
  - [123-买卖股票的最佳时机III](例题/123-买卖股票的最佳时机III.md)
  - [188-买卖股票的最佳时机IV](例题/188-买卖股票的最佳时机IV.md)
  - [309-最佳买卖股票时机含冷冻期](例题/309-最佳买卖股票时机含冷冻期.md)
  - [714-买卖股票的最佳时机含手续费](../9-贪心/例题/714-买卖股票的最佳时机含手续费.md)

### 子序列问题
- 子序列问题通常使用二位dp数组，更方便理解
- 同时，状态转移方程中的下标可能会有一些变化，此时一定要注意dp数组与下标的定义，这一点非常重要
- 对应问题：
  - [300-最长递增子序列](例题/300-最长递增子序列.md)
  - [674-最长连续递增序列](例题/674-最长连续递增序列.md)
  - [718-最长重复子数组](例题/718-最长重复子数组.md)
  - [1143-最长公共子序列](例题/1143-最长公共子序列.md)
  - [1035-不相交的线](例题/1035-不相交的线.md)
  - [53-最大子序和](../9-贪心/例题/53-最大子序和.md)
  - [392-判断子序列](例题/392-判断子序列.md)
  - [115-不同的子序列](例题/115-不同的子序列.md)
  - [583-两个字符串的删除操作](例题/583-两个字符串的删除操作.md)
  - [72-编辑距离](例题/72-编辑距离.md)
  - [647-回文子串](例题/647-回文子串.md)
  - [516-最长回文子序列](例题/516-最长回文子序列.md)